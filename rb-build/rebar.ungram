// Rebar Un-Grammar.
//
// This grammar specifies the structure of Rebar's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          -- comment
//   Name =      -- non-terminal definition
//   'ident'     -- token (terminal)
//   A B         -- sequence
//   A | B       -- alternation
//   A*          -- zero or more repetition
//   A?          -- zero or one repetition
//   (A)         -- same as A
//   label:A     -- suggested name for field of AST node

Name = 'ident'

BinaryOp = '+' | '-' | '*' | '/' | '==' | '!=' | '<' | '<=' | '>' | '>='

Expr =
  'integer' |
  'float' |
  String |
  CallExpr |
  FieldExpr |
  BinaryExpr |
  IfExpr |
  Block

String = '"' 'char'* Escape* '"'
Escape = '\\' 'ident'

FieldExpr = Expr '.' Name
BinaryExpr = Expr BinaryOp Expr

IfExpr = 'if' Expr Block ('else' 'if' Expr Block)* ('else' Block)?

Block = '{' (Stmt 'nl')* '}'

Type = Name

CallExpr = Expr ParenArgs
ParenArgs = '(' Expr (',' Expr)* ')'

Stmt = Def | Struct | Assign | Expr

Assign = Expr '=' Expr

Def = 'def' Name ArgsDef Block
Struct = 'struct' Name StructBlock

ArgsDef = '(' ArgDef* ')' ('->' Type)?
ArgDef = Name ':' Type

StructBlock = '{' StructItem* '}'
StructItem = Property | Def | ConstructorDef
ConstructorDef = 'constructor' ArgsDef Block

Property = Name ':' Type

SourceFile = Stmt*

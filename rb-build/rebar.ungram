// Rebar Un-Grammar.
//
// This grammar specifies the structure of Rebar's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          -- comment
//   Name =      -- non-terminal definition
//   'ident'     -- token (terminal)
//   A B         -- sequence
//   A | B       -- alternation
//   A*          -- zero or more repetition
//   A?          -- zero or one repetition
//   (A)         -- same as A
//   label:A     -- suggested name for field of AST node

Name = 'ident'
Path =
  SimplePath |
  FullyQualifiedPath
SimplePath = 'ident'* '::'*
FullyQualifiedPath = '<' struct_type:SimplePath 'as' trait_type:SimplePath '>' 'ident'

BinaryOp = '+' | '-' | '*' | '/' | '%' | '==' | '!=' | '<' | '<=' | '>' | '>=' | '&&' | '||' | '&' | '|' | '^' | '<<' | '>>'
PrefixOp = '-' | '!'
PostfixOp = '-' // TODO
TypeOp = '|'

Literal = 'integer' | 'float' | 'true' | 'false' | 'nil'

Expr =
  Literal |
  PathExpr |
  String |
  CallExpr |
  IndexExpr |
  FieldExpr |
  PrefixExpr |
  PostfixExpr |
  BinaryExpr |
  AsExpr |
  IfExpr |
  ParenExpr |
  ArrayExpr |
  StructExpr |
  Block

String = '"' 'char'* Escape* Interpolation* '"'
Escape = '\\' 'ident'
Interpolation = '#' '{' Expr '}'

PathExpr = Path
FieldExpr = Expr '.' 'ident'
PrefixExpr = PrefixOp Expr
PostfixExpr = PostfixOp Expr
BinaryExpr = Expr BinaryOp Expr
AsExpr = Expr 'as' Type

IfExpr = 'if' Expr Block ('else' 'if' Expr Block)* ('else' Block)?

ParenExpr = '(' Expr ')'
ArrayExpr = '[' Expr* ']'
Block = '{' Stmt* '}'

Type = NameType | RefType | BinaryType | NeverType

NameType = 'ident' | 'nil'
RefType = '&' 'mut'? Type
BinaryType = Type TypeOp Type
NeverType = '!'

CallExpr = Expr '(' ArgList ')'
ArgList = Expr (',' Expr)*

IndexExpr = Expr '[' Expr ']'

StructExpr = Path '{' FieldInit* '}'
FieldInit = 'ident' ':' Expr

ExprStmt = Attr* Expr
Stmt = Use | Mod | Struct | Function | Let | Assign | ExprStmt

Mod = Attr* 'mod' 'ident' Block?
Use = Attr* 'use' Path

Let = Attr* 'let' 'ident' (':' Type)? '=' Expr
Assign = Attr* Expr '=' Expr

Function = Attr* Extern? 'fn' 'ident' Params Block
Extern = 'extern' String?
Attr = '#' '[' Path ']'
Struct = Attr* 'struct' 'ident' StructBlock

Params = '(' Param* ')' ReturnType?
Param = 'ident' ':' Type
ReturnType = '->' Type

StructBlock = '{' Field* '}'

Field = 'ident' ':' Type

SourceFile = Stmt*

// FIXME: Get rid of this hack. `nl` should be part of `SyntaxKind`, but not part of the grammar.
always_make_nl = 'nl' | '!'
